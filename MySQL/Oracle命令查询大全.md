# Oracle命令查询大全

## 1

```SQL
--创建用户名和密码
CREATE USER USERNAME IDENTIFIED BY PASSWD;
```

## 2

```SQL
--授权
GRANT CONNECT, RESOURCE, DBA TO USERNAME;
```

## 3

```SQL
--连接、进入
CONNECT USERNAME/PASSWD;
```

## 4、

```SQL
--查询表名、字段
SELECT TABLE_NAME, COLUMN_NAME FROM USER_TAB_COLUMNS
WHERE TABLE_NAME = 'mview_log';
```

## 5

```SQL
--执行SQL文件
SQL>@PATH/FILENAME.sql
```

## 6

```SQL
/*
Oracle oledb 提供者在command中执行多条SQL语句与SQL SERVER有少许差别,SQL Server只需使用";"分割多条SQL语句,而Oracle需要遵守ORACLE调用规范,即除分号分割外,还需以begin /end;包围语句体
*/
--使用C#描述应如下所示:
this.oleDbCommand1.CommandText = "begin INSERT INTO GROUP_INFO (GROUP_ID, GROUP_NAME) VALUES (1, \'2\'); INSERT INTO GROUP_INFO(GROUP_ID, GROUP_NAME) VALUES (2, \'2\'); end;";
```

## 7

```SQL
--查询用户下的所有表
SELECT DISTINCT TABLE_NAME USER_TAB_COLUMNS;
```

## 8

```SQL
--检索、搜索出前N条记录
SELECT A.*, ROWNUM FROM (
	SELECT * FROM CARDKIND ORDER BY CARDKID
) A 
WHERE ROWNUM < N;
```

## 9

```SQL
--查找用户下的所有表
SELECT * FROM TAB;
```

## 10

```SQL
--显示当前连接的用户
SHOW USER;
```

## 11

```SQL
--查看系统拥有的用户
SELECT * FROM ALL_USERS;
```

## 12

```SQL
--创建新用户并授权
CREATE USER A IDENTIFIED BY A; --默认建在SYSTEM表空间下
GRANT CONNECT, RESOURCE TO A; --授权
```

## 13

```SQL
--连接新用户 A
CONN A/A
```

## 14

```SQL
--查询当前用户下所有的对象
SELECT * FROM TAB;
```

## 15

```SQL
--创建表
CREATE TABLE B(
	b NUMBER
);
```

## 16

```SQL
--查看表结构
DESC B;
```

## 17

```SQL
--插入新记录
INSERT INTO B VALUES(1);
```

## 18

```SQL
--查询记录
SELECT * FROM B;
```

## 19

```SQL
--更改记录
UPDATE B SET b = 2;
```

## 20

```SQL
--删除记录
DELETE FROM B;
```

## 21

```SQL
--回滚
ROLL;
ROLLBACK;
```

## 22

```SQL
--提交
COMMIT;

SELECT * FROM (
	SELECT T.*, DENSE_RANK() OVER(ORDER BY CARDKIND) RANK FROM CRADKIND T)
)
WHERE RANK = 2;
```

## 23

```SQL
--如何在字符串里面加回车
SELECT 'WELCOME TO VISIT'||CHR(10)||'ORACLE' FROM DUAL;
```



## 24

```SQL
/*
中文如何排序:
	1、Oracle 9i 之前， 中文是按照二进制编码进行排序的
	2、SCHINESE_RADICAL_M 按照首部(第一顺序)、笔画(第二顺序) 排序
	3、SCHINESE_STROKE_M  按照笔画(第一顺序)、部首(第二顺序) 排序
	4、SCHIMESE_PINYIN_M  按照拼音排序
*/
```

## 25

```SQL
--Oracle 8i中对象名可以使用中文？
可以
```

## 26

```SQL
--如何修改Oracle数据库的默认日期
SQL * PLUS 自身的选项设置我们可以在$ORACLE_HOME/SQLPLUS/ADMIN/GLOGIN.SQL中设置
```

## 27

```SQL
--如何修改ORACLE数据库的默认日期
ALTER SESSION SET NLS_DATE_FORMATE = 'YYYYMMDDHH24MISS';
--或者
--在INIT.ORA中加上一行
NLS_DATE_FORMATE = 'YYYYMMDDHH24MISS'
```

## 28

```SQL
--如何将小表放入KEEP池中
ALTER TABLE TABLE_NAME STORAAGE(BUFFER_POOL KEEP);
```

## 29

```SQL
--如何检查是否安装了某个PATCH
CHECK THAT ORAINVENTORY
```

## 30

```SQL
--如何使用SELECT语句将查询结棍自动生成序号
SELECT ROWNUM, COL FROM TABLE;
```

## 31

```SQL
--如何知道数据库中某个表所在的TABLESPACE
SELECT TABLESPACE_NAME FROM USER_TABLES WHERE TABLE_NAME = 'TEST';
SELECT * FROM USER_TABLES --中有字段TABLESPACE_NAME, (ORACLE);
SELECT * FROM DBA_SEGMENTS WHERE......;
```

## 32

```SQL
--如何快速对原表进行一个备份
CREATE TABLE NEW_TABLE AS (SELECT * FROM OLD_TABLE);
```

## 33

```SQL
--如何在SQLPLUS下修改PROCEDURE
SELECT LINE, TRIM(TEXT) T FROM USER_SOURCE WHERE NAME = 'A' ORDER BY LINE;
```

## 34

```SQL
--如何解除PROCEDURE被意外锁定
ALTER STSTEN KILL SESSION
--查询出SESSION ID 并KILL 或 将改过程名进行修改
```

## 35

```SQL
--SQL REFERENCE是什么？
是一本基于SQL的使用手册，包括语法、函数等等
(可在ORACLE官网下载)
```

## 36

```SQL
--如何查看数据库状态
--LINUX下
PS -EF | GERP ORA

--WINDOWS
1、查看服务是否启动
2、进行连接，能否连接上数据库
```

## 37

```SQL
--如何修改一张表的主键
ALTER TABLE AA;
DROP CONSTRAINT AA_KEY;
ALTER TABLE AA;
ADD CONSTRAINT AA_KEY PRIMARY KEY(A1, B1);
```

## 38

```SQL
--如何改变数据文件的大小
ALTER DATABASE...DATAFILE...;
--手动修改数据文件大小，对于原来的数据文件并没有损害
```

## 39

```SQL
--如何查看数据库中存在多少个TABLESPACE
SELECT * FROM DBA_TABLESPACE;
```

## 40

```SQL
--如何查看ORACLE中那些程序在运行之中
SELECT * FROM V$SESSIONS
```

## 41

```SQL
--如何修改ORACLE数据库的用户连接数量
修改INITSID.ORA，将PROCESS加大，重启数据库
```

## 42

```SQL
--如何查询出一条记录的最后更新时间
LOGMINER查看
```

## 43

```SQL
--如何在PL/SQL中读写文件
UTL_FILE包运行用户通过PLSQL读写操作系统文件
```

## 44

```SQL
--如何将“&”放入一条记录中
INSERT INTO A VALUES (TRANSLATE('AT{&}T', 'AT{}', 'AT'));
```

## 45

```SQL
--.EXP如何QUERY参数
EXP USER/PASS FILE = A.DMP TABLES(BSEMPMS)
QUERY = "'WHERE EMP_NO = \'S09394\'\";
```

## 46

```SQL
--关于ORACLE 8I支持简体和繁体的字符集问题
ZHS16GBK可支持
```

## 47 

```SQL
--DATA GUARD是什么软件
STANDBY的换代产品
```

## 48

```SQL
--如何创建SPFILE
1. 
CONNECT / AS SYSDBA

2.
SELECT * FROM V$VERSION;

3.
CREATE PFILE FROM SPFILE;

4.
CREATE SPFILE = 'E:\ORA9\DATABASE\SPFILEEYGLE.ORA' FROM PFILE = 'E:\ORA9I\ADMIN\EYGLE\PFILE\INIT.ORA';
```

## 49

```SQL
--内核参数的应用
SHMMAX
/*
解释：其含义是这个设置并不决定究竟ORACLE数据或者操作系统使用多少物理内存，只决定了最多可以使用内存的数目。这个设置也不影响操作系统的内核资源。
设置方式：
0.5 * 物理内存
例子：
SET SHMSYS:SHMINFO_SHMMAX = 10485760;

SHMMIN:共享内存的最小大小
设置方式：一般都设置为1
例子：
SET SHMSYS:SHMINFO_SHMMIN = 1;

SHMMNI:系统中共享内存段的最大个数
例子：
SET SHMSYS:SHMINFO_SHMMNI = 100;

SHMSEG:每个用户进行可以使用的最多的共享内存段的数目
例子：
SET SHMSYS:SHMINFO_SHMSEG = 20;

SEMMNI:系统中SEMAPHORE IDENTIFIERER的最大个数
设置方式：把这个变量的值设置为系统上的所有ORACLE的实列的INIT.ORA中的最大的PROCESSES的值加100
例子：
SET SEMSYS:SEMINFO_SEMMNI = 100;

SEMMNS:系统中EMAPHORES的最大个数
设置方式：这个值可以通过以下的方式计算得到：各个ORACLE实列的INITSID.ORA里面的PROCESSES的值的总和(除去最大的PRODESSES参数) + 最大的PROCESSES * 2 + 10 + ORACLE实列的个数。
例子：
SET SEMSYS:SEMINFO_SEMMNS = 200;

SEMMSL:一个SET中SEMAPHORE的最大个数
设置方式：设置为10 + 所有ORACLE实列的INIT.ORA中最大的PROCESSES的值
例子：
SET SEMSYS:SEMINFO_SEMMSL = -200;
*/
```

## 50

```SQL
--如何查看那些用户拥有SYSDBA、SYSOPER权限
CONN SYS/CHANGE_ON_INSTALL;
SELECT * FROM V_$PWFILE_USERS;
```

## 51

```SQL
--如何单独备份一张或多张表
EXP 用户/密码 TABLES = (TABLE_NAME_1, TABLE_NAME_2,......);
```

## 52

```SQL
--如何单独备份一个或多个用户
EXP SYSTEM/MANGER OWNER = (USER_NAME_1, USER_NAME_2, USER_NAME_N) FILE = 导出文件;
```

## 53

```SQL
--如何对CLOB字段进行全文检索
SELECT * FROM A WHERE DBMS_LOB.INSTR(A.A, 'K', 1, 1) > 0;
```

## 54

```SQL
--如何查看数据文件放置的路径
COL FILE_NAME FORMAT A50
SELECT TABLESPACE_NAME, FILE_ID, BYTES/1024/1024, FILE_NAME FROM DBA_DATA_FILES ORDER BY FILE_ID;
```

## 55

```SQL
--如何查看现有回滚段机器状态
COL SEGMENT FORMAT A30;
SELECT SEGMENT_NAME, OWNER, TABLESPACE_NAME, SEGMENT_ID, FILE_ID, STATUS FROM DBA_ROLLBACK_SEGS;
```

## 56

```SQL
--如何改变字段初始定义的CHECK范围
ALTER TABLE TABLE_NAME DROP CONSTRAINT CONSTRAINT_NAME
--再创建新约束
ALTER TABLE TABLE_NAME ADD CONSTRAINT CONSTRAINT_NAME CHECK();
```

## 57

```SQL
--ORACLE常用系统文件
--通过以下视图显示文件信息：
1、V$DATABASE
2、V$DATAFILE
3、V$LOGFILE
4、V$CONTROLFILE
5、V$PARAMETER
```

## 58

```SQL
--内连接(INNER JOIN)
SELECT A.* FROM BSEMPMS A, BSDPTMS B WHERE A.DPT_NO = B..DPT_NO;
```

## 59

```SQL
--外连接
SELECT A.* FROM BSEMPMS A, BSDPTMS B WHERE A.DPT_NO = B.DPT_NO(+);
SELECT A.* FROM BSEMPMS A, BSDPTMS B WHERE A.DPT_NO(+) = B.DPT_NO;
```

## 60

```SQL
--如何执行SQL文件
@$PATH/FILENAME.sql;
```

## 61

```SQL
--如何快速清空表
TRUNCATE TABLE TABLE_NAME;
```

## 62

```SQL
--如何查询存在多少个数据库实列
SELECT * FROM V$INSTANCE;
```

## 63

```SQL
--如何查询数据库存在多少表
SELECT * FROM ALL_TABLES;
```

## 64

```SQL
--如何测试SQL语句执行耗费时间
SET TRMING ON;
SELECT * FROM TABLENAME;
```

## 65

```SQL
--CHR()的反函数
ASCII()
SELECT CHR(65) FROM DUAL;
SELECT ASCII('A') FROM DUAL;
```

## 66

```SQL
--字符串拼接
SELECT CONCAT(COL_1, COL_2) FROM TABLE_NAME;
SELECT COL_1||COL_2 FROM TABLE_NAME;
```

## 67

```SQL
--如何将SELECT结棍导入到文件
1.
SPOOL C:\ABCD.TXT

2.
SELECT * FROM TABLE;

3.
SPOOL OFF;
```

## 68

```SQL
--如何估算SQL执行的I/O数
1.
SET AUTOTRACE ON;

2.
SELECT * FROM TABLE;
--OR
SELECT * FROM V$FILESTAT;
```

## 69

```SQL
--如何在SQLPLUS下改变字段大小
ALTER TABLE TABLE_NAME MODIFY(FIELD_NAME VARCHAR2(100));
```

## 70

```SQL
--如何查询具体某天的数据
SELECT 
	* 
FROM 
	TABLE_NAME
WHERE 
	TRUNC(日期字段) = TO_DATE('2000-01-01', 'YYYY-MM-DD');
```

## 71

```SQL
--SQL语句如何插入全年日期
1.
CREATE TABLE ALL_YEAR(
	AY DATE
);

2.
INSERT INTO 
	ALL_YEAR
SELECT 
	TO_DATE('20010101', 'YYYYMMDD') + ROWNUM - 1
FROM 
	ALL_OBJECTS
WHERE 
	ROWNUM <= TO_CHAR(TO_DATE('20000101', 'YYYYMMDD'), 'DDD');
```

## 72

```SQL
--如何修改表名
ALTER TABLE OLD_TABLE_NAME RENAME TO NEW_TABLE_NAME;
```

## 73

```SQL
--如何获取命令的返回状态值
SQLCODE  = 0;
```

## 74

```SQL
--如何获取用户拥有的权限
SELECT * FROM DBA_SYS_PRIVS;
```

## 75

```SQL
--网上ORACLE 9I 与市场标准版的区别
从功能上说没有区别，只不过oracle公司有明文规定；从网站上下载的oracle产品不得用于
商业用途，否则侵权。
```

## 76

```SQL
--如何判断数据库是否运行在归档模式下还是在非归档模式下
1.进入DBASTUDIO

2.历程

3.数据库

4.归档查看
```

## 77

```SQL
--STARTUP PFILE和IFILE, SPFILE区别
1、PFILE是ORACLE传统的初始化参数文件，文本格式
2、IFILE类似于C拥有的INCLUDE，用于把另一个文件引入
3、SPFILE是9I新增的，并且是默认的参数文件，二进制格式，STARTUP后应该只可接PFILE
```

## 78

```SQL
--如何减少前N条记录
SELECT * FROM EMPLOYEE WHERE ROWNUM < N ORDER BY EMPNO;
```

## 79

```SQL
--如何获取机器上ORACLE支持多少并发用户数
1.
CONN INTERNAL

2.
SHOW PARMETER PROCESS;
```

## 80

```SQL
--DB_BLOCK_SIZE允许修改？
一般不可以，并不建议这样做
```

## 81

```SQL
--如何统计两表的记录总数
SELECT (
	SELECT COUNT(ID) FROM AA + SELECT COUNT(ID) FROM BB
) '总数' FROM DUAL;
```

## 82

```SQL
--如何使用SQL语句实现查找一列的第N大值
SELECT * FROM(
	SELECT T.*, DENSE_RANK() OVER (ORDER BY SAL) RANK FROM EMPLOYEE
)
WHERE RANK = N;
```

## 83

```SQL
--如何在现有日期加上2年时间
SELECT ADD_MONTHS(SYSDATE, 24) FROM DUAL;
```

## 84

```SQL
--USED_UBLK为负表示什么？
IT IS "HARMLESS"
```

## 85

```SQL
--CONNECT STRING是什么？
指TNSNAMES.ORA中的服务名后面的内容
```

## 86

```SQL
--如何扩大REDO LOG的大小
建立一个临时的REDOLO组，然后进行日志切换，删除一起的日志，并建立新的日志
```

## 87

```SQL
--TABLESPACE是否不能大于4G
并无限制
```

## 88

```SQL
--返回大于等于N的最小整数值
SELECT CEIL(N) FROM DUAL;
```

## 89

```SQL
--返回小于等于N的最小整数值
SELECT FLOOR(N) FROM DUAL;
```

## 90

```SQL
--返回当前月份的最后一天
SELECT LAST_DAY(SYSDATE) FROM DUAL;
```

## 91

```SQL
--如何将不同用户间的数据进行导入
IMP SYSTEM/MANAGER FILE = AA.DMP FROM USER = USER_OLD TO USER = USER_NEW ROWS = Y INDEXS = Y;
```

## 92

```SQL
--如何查找数据库表的主键字段的名称
SELECT * FROM USER_CONSTRAINT WHERE CONSTRAINT_TYPE = 'P' AND TABLE_NAME = 'TABLE_NAME';
```

## 93

```SQL
--将两结果集互加的函数
SELECT * FROM BSEMPMS_OLD INTERSECT SELECT * FROM BSEMPMS_NEW;
SELECT * FROM BESMPMS_OLD UNION SELECT * FROM BSEMPMS_NEW;
SELECT * FROM BSEMPMS_OLD UNION ALL SELECT * FROM BSEMPMS_NEW;
```

## 94

```SQL
--将两结果集互减的函数
SELCT * FROM BSEMPMS_OLD MINUS SELECT * FROM BSEMPMS_NEW;
```

## 95

```SQL
--如何配置SEQUENCE
1.
CREATE SEQUENCE SEQ_CUSTID START 1 INCREMENT BY 1;

2.建表时
CREATE TABLE CUST(
	CUST_ID SAMLLINT NOT NULL,
)

3.INSERT时
INSERT INTO TABLE CUST VALUE(SEQ_CUST.NECTVAL,....)
```

## 96

```SQL
--取时间点的年份SQL
SELECT TO_CHAR(SYSDATE, 'YYYY') FROM DUAL;
```

## 97

```SQL
--取时间点的日期SQL
SELECT TO_CHAR(SYSDATE, 'DD') FROM DUAL;
```

## 98

```SQL
--取时间点的时SQL
SELECT TO_CHAR(SYSDATE, 'MI') FROM DUAL;
```

## 99

```SQL
--取时间点的分SQL
SELECT TO_CHAR(SYSDATE, 'SS') FROM DUAL;
```

## 100

``` SQL
--取时间点的日期SQL
SELECT TRUNC(SYSDATE) FROM DUAL
```

## 101

```SQL
--取时间点的时间SQL
SELECT TO_CHAR(SYSDATE, 'HH24:MI:SS') FROM DUAL;
```

## 102

```SQL
--日期、时间形态变为字符形态
SELECT TO_CHAR(SYSDATE) FROM DUAL;
```

## 103

```SQL
--将字符转换成日期或者时间形态
SELECT TO_DATE('2000/01/01') FROM DUAL;
```

## 104

```SQL
--返回参数的星期几的写法
SELECT TO_CHAR(SYSDATE, 'D') FROM DUAL;
```

## 105

```SQL
--返回参数一年中的第几天的写法
SELECT TO_CHAR(SYSDATE, 'DDD') FROM DUAL;
```

## 106

```SQL
--返回午夜和参数中指定的时间值之间的秒数
SELECT TO_CHAR(SYSDATE, 'SSSSS') FROM DUAL;
```

## 107

```SQL
--返回参数中一年的第几周
SELECT TO_CHAR(SYSDATE, 'WW') FROM DUAL;
```

## 108

```SQL
--CYRRVAL 和 NEXTVAL
1、为表创建序列
CREATE SEQUENCE EMPSEQ,....;
SELECT EMPSEQ.CURRVAL FROM DUAL;

2、自动插入序列的数值
INSERT INTO EMP VALUES(EMPSEQ.NEXTVAL, 'LEWIS', 'CLERK', 1001, SYSDATE, 2000, NULL)
```

## 109

```SQL
--ROWNUM：按设定排序的行的序号
SELECT * FROM EMP WHERE ROWNUM < 10;
```

## 110

```SQL
--ROWID：返回行的物理地址
SELECT  ROWID, ENAME FROM EMP WHERE DEPTNO = 20;
```

## 101

```SQL
--将N秒转换为分秒格式
SET SERVEROUT ON
DECLARE
	N NUMBER := 1000000;
	RET VARCHAR2(100);
BEGIN
	RET := TRUNC(N/3600)||'小时'||TO_CHAR(TO_DATE(MOD(N, 3600), 'SSSSS'), 'FEN' "分" 'S' "秒");
DBMS_OUTPUT.PUT_LINE(RET);
END;
```

## 102

```SQL
--如何查询做排序比较大的进程
SELECT B.TABLESPACE, B.SEGFILE#, B.SEGBLK#, B.BLOCKS, A.SID, A.SERIAL#, A.USERNAME, A.OSUSER, A.STATUS FROM V$SESSION A, V$SORT_USAGE B WHERE A.SADDR = B.SESSION_ADDR ORDER BY B.TABLESPACE, B.SEGFILE#, B.SEGBLK#, B.BLOCKS;
```

## 103

```SQL
--如何获取查询比较大的排序的进行
SELECT /* + ORDERED */SQL_TEXT FROM V$SQLTEXT A WHERE A.HASH_VALUE = ( SELECT SQL_HASH_VALUE FROM V$SESSION B WHERE B.SID = &SID AND B.SERIAL# = &SERIAL) ORDER BY PIECE ASC;
```

## 104

```SQL
--如何查找重复记录
SELECT * FROM TABLE_NAME WHERE ROWID != ( SELECT MAX(ROWID) FROM TABLE_NAME D WHERE TABLE_NAME.COL1 = D.COL1 AND TABLE_NAME.COL2 = D.COL2);
```

## 105

```SQL
--如何删除重复记录
DELETE FROM  TABLE_NAME WHERE ROWID != ( SELECT MAX(ROWID) FROM TABLE_NAME D WHERE TABLE_NAME.COL1 = D.COL1 AND TABLE_NAME.COL2 = D.COL2);
```

## 106

```SQL
--如何快速编译所有视图
1.
SPOOL VIEW_1.sql

2.
SELECT 'ALTER VIEW'||TNAME||'COMPILE;'FROM TAB;

3.
SPOOL OFF

4.
执行VIEW_1.sql
@VIEW_1.sql
```

## 107

```SQL
--ORA-01555 SNAPSHOP TOO OLD 的解决方案
增加MANEXTENTS的值，增加区的大小，设置一个高的OPTIMAL的值
```

## 108

```SQL
--进行事务操作时，回滚段空间不够，表现为表空间用满(ORA-01569错误)，回滚段扩展到达参数MAXEXTENTS的值(ORA-01628)的解决方案
向回滚段表空间添加文件或使已有的文件变大，或增加MAXEXTENTS的值
```

## 109

```SQL
--如何加密ORACLE的存储过程
例子：存储过程内容放在BB.sql文件中
1.
CREATE OR REPLACE PRODUCEDURE TESTCCB(I IN NUMBER) AS
BEGIN
	DBMS_OUTPUT.PUT_LINE('输入参数是'||TO_CHAR(I));
END;

2.
WRAP INAME = B.sql;

3.
@BB.sql

```

## 110

```SQL
--如何监控事例的等待
SELECT EVENT, SUM(DECODE(WAIT_TIME, 0, 0, 1)) "PREV", SUM(DECODE(WAIT_TIME, 0, 1, 0)) "CURR", COUNT(*) "TOT" FROM V$SESSION_WAIT GROUP BY EVENT ORDER BY 4;
```

## 111

```SQL
--如何获取回滚段的使用情况
SELECT NAME, WAITS, GETS, WAITS/GETS "RATIO" FROM V$ROLLSTAT C, V$ROLLNAME D WHERE C.USN = D.USN;
```

## 112

```SQL
--如何监控表空间的I/O比例
SELECT B.TABLESPACE_NAME NAME, B.FILE_NAME "FILE", A.PHYRDS PYR, A.PHYBLKRD PBR, A.PHYWRTS PYW, A.PHYBLKWRT PBW FROM V$FILESTAT A, DBA_DATA_FILES B WHERE A.FILE# = B.FILE_ID ORDER BY B.TABLESPACE_NAME;
```

## 113

```SQL
--如何监控文件系统的I/O比例
SELECT SYBSTR(C.FILE#, 1, 2) "#", SUBSTR(C.NAME, 1, 30) "NAME", C.STATUS, C.BYTES, D.PHYRDS, D.PHYWRTS FROM V$DATAFILE C, V$FILESTAT D WHERE C.FILE# = D.FILE#;
```

## 114

```SQL
--如何查找某个用户下的所有索引
SELECT USER_INDEXES.TABLE_NAME, USER_INDEXES.INDEX_NAME, UNIQUENESS, COLUMN_NAME FROM USER_LND_COLUMNS, USER_INDEXES WHERE USER_IND_COLUMNS.INDEX_NAME = USER_INDEXES.INDEX_NAME AND USER_IND_COLUMNS.TABLE_NAME = USER_INDEXES.TABLE_NAME ORDER BY USER_INDEXES.TABLE_TYPE, USER_INDEXES.TABLE_NAME, USER_INDEXES.INDEX_NAME, COLUMN_POSITION;
```

## 115

```SQL
--如何监控SGA的命中率
SELECT A.VALUE + B.VALUE "LOGICAL_READS", C.VALUE "PHY_READS", ROUND(100 * ((A.VALUE + B.VALUE) - C.VALUE) / (A.VALUE + B.VALUE)) "BUFFER HIT RATIO" FROM V$SYSSTAT A, V$SYSSTAT B, V$SYSSTAT C WHERE A.STATISTIC# = 38 AND B.STATISTIC# = 39 AND C.STATISTIC# = 40；
```

## 116

```SQL
--如何监控SGA中字段字段缓冲区的命中率
SELECT PARAMETER, GETS, GETMISSES, GETMISSES/(GETS + GETMISSES) * 100 "MISS RATIO", (1 - (SUM(GETMISSES) / (SUM(GETS) + SUM(GETMISSES)))) * 100 "HIT RATIO" FROM V$ROWCACHE WHERE GETS + GETMISSES <> 0 GROUP BY PARAMTER, GETS, GETMISSES;
```

## 117

```SQL
--如何监控SGA中共享缓存区的命中率，应该小于1%？
SELECT SUM(PINS) "TOTAL PINS", SUM(RELOADS) "TOTAL RELOADS", SUM(RELOADS) / SUM(PINS) * 100 LIBCACHE FROM V$LIBRARYCACHE;
SELECT SUM(PINHITS - RELOADS) / SUM(PINS) "HIT RADIO", SUM(RELOADS) / SUM(PINS) "RELOAD PERCENT" FROM V$LIBRARYCACHE;
```

## 118

```SQL
--如何显示索引数据库对象的类别和大小
SELECT COUNT(NAME) NUM_INSTANCES, TYPE, SUM(SOURCE_SIZE) SOURCE_SIZE, SUM(PARSED_SIZE) PARSED_SIZE, SUM)CODE_SIZE CODE_SIZE, SUM) ERROE_SIZE, SUM(SOURCE_SIZE) + SUM(PARSED_SIZE) + SUM(CODE_SIZE) + SUM(ERROR_SIZE) SIZE REQUIRED FROM DBA_OBJECT_SIZE GROUP TYPE ORDER BY 2;
```

## 119

```SQL
--监控SGA中重做日志缓存区的命中概率，应该小于1%？
SELECT NAME, GETS, MISSES, IMMEDIATE_GETS, IMMEDIATE_MISSES, DECODE(IMMEDIATE_GETS + IMMEDIATE_MISSES, 0, 0, IMMEDIATE_MISSES / (IMMEDIATE_GETS + IMMEIDATE_MISSES) * 100) RATIO2 FROM V$LATCH WHERE NAME IN ('REDO ALLOCATION', 'REDO COPY');
```

## 120

```SQL
--监控内存和硬盘的排序比率，最好使它小于.10，增加SORT_AREA_SIZE
SELECT NAME, VALUE FROM V$SYSSTAT WHERE NAME IN ('SORTS(MEMORY)', 'SORTS(DISK)');
```

## 121

```SQL
--如何监控当前数据库运行的SQL
SELECT OSUSER, USERNAME, SQL_TEXT FROM V$SESSION A, V$SQLTEXT B WHERE A.SQL_ADDRESS = B.ADDRESS ORDER BY ADDRESS, PIECE;
```

## 122

```SQL
--如何监控字段缓冲区
SELECT (SUM(PINS - RELOADS)) / SUM(PINS) "LIB CACHE" FROM V$LIBRARYCACHE;
SELECT (SUM(GETS - GETMISSES - USAGE - FIXED)) / SUM(GETS) "ROW CACHE" FROM V$ROWCACHE;
SELECT SUM(PINS) "EXECUTIONS", SUM(RELOADS) "CACHE MISSES WHILE EXCUTING" FROM V$LIBRARYCACHE;

--后者除以前者，此比例小于1%，接近为0%为好
SELECT SUM(GETS) "DICTIONARY GETS", SUM(GETMISSES) "DICTIONARY CACHE GET MISSES" FROM V$ROWCACHE;
```

## 123

```SQL
--监控MTS
SELECT BUSY / (BUSY + IDLE) "SHARED SERVERS BUSY" FROM V$DISPATCHER;

--当大于0.5是，参数需要加大
SELECT SUM(WAIT) / SUM(TOTALQ) "DISPATCHER WAITS" FROM V$QUEUE WHERE TYPE = 'DISPATCHER'; 
SELECT COUNT(*0 FROM V$DISPATCHER);
SELECT SERVER_HIGHWATER FROM V$MTS;
--SERVERS_HIGHWATER接近MTS_MAX_SERVERS时，参数加大
```

## 124

```SQL
--如何获取当前用户的ID
SHOW USER;
--OR
SELECT USER FROM DUAL;
```

## 125

```SQL
--如何查看碎片程度高的表
SELECT SEGMENT_NAME TABLE_NAME, COUNT(*) EXTENTS FROM DBA_SEGMENTS WHERE OWNER NOT IN ('SYS', 'SYSTEM') GROUP BY SEGMENT_NAME HAVING COUNT(*) = (SELECT MAX(COUNT(*) FROM DBA_SEGMENTS HROUP BY SEGMENT_NAME);
```

## 126

```SQL
--如何获取表在表空间的存储情况
SELECT SEGMENT_NAME, SUM(BYTES), COUNT(*) EXT_QUAN FROM DBA_EXTENTS WHERE TABLESPACE_NAME = '&TABLESPACE_NAME' AND SEGMENT_TYPE = 'TABLE' GROUP BY TABLESPACE_NAME, SEGMENT_NAME;
```

## 127

```SQL
--如何获取索引在表空间的存储情况
SELECT SEGMENT_NAME, COUNT(*) FROM DBA_EXTENTS WHERE SEGMENT_TYPE = 'INDEX' AND OWNER = '&OWNER' GROUP BY SEGMENT_NAME;
```

## 128

```SQL
--如何获取使用CPU多的用户SESSION
11 是 CPU USED BY THIS SESSION

SELECT A.SID, SPID, STATUS, SUBSTR(A.PROGRAM, 1, 40) PROG, A.TERMINAL, OSUSER, VALUE /60/100 VALUE FROM V$SESSION A, V$PROCESS B, V$SESSTAT C WHEREC.STATISTIC# = 11 AND C.SID = A.SID AND A.PADDR = B.PADDR ORDER BY VALUE DESC;
```

## 129

```SQL
--如何获取监听器日志文件(8I为例)
$ORACLE_HOME/NETWORK/LOG/LISTENER.LOG
```

## 130

```SQL
--如何获取监听器参数文件
$ORACLE_HOME/NETWORK/ADMIN/LISTENER.ORA
```

## 131

```SQL
--如何获取TNS连接文件
$ORACLE_HOME/NETWORK/ADMIN/TNSNAMES.ORA
```

## 132

```SQL
--如何获取SQL * NET环境文件
$ORACLE_HOME/NETWORK/ADMIN/SQLNET.ORA
```

## 133

```SQL
--如何获取警告日志文件
$ORACLE_HOME/ADMIN/SID/BDUMP/SIDALRT.LOG
```

## 134

```SQL
--如何获取基本机构
$ORACLE_HOME/RDBMS/ADMIN/STANDARD.SQL
```

## 135

```SQL
--如何获取建立数据字段视图
$ORACLE_HOME/EDBMS/ADMIN/CATALOG.SQL
```

## 136

```SQL
--ORACLE SQL优化
/*+ALL_ROWS*/
表明对语句块选择基于开销的优化方法,并获得最佳吞吐量,使资源消耗最小化.
例如:
SELECT /*+ALL+_ROWS*/ EMP_NO,EMP_NAM,DAT_IN FROM BSEMPMS WHERE EMP_NO='CCBZZP';


/*+FIRST_ROWS*/
表明对语句块选择基于开销的优化方法,并获得最佳响应时间,使资源消耗最小化.
例如:
SELECT /*+FIRST_ROWS*/ EMP_NO,EMP_NAM,DAT_IN FROM BSEMPMS WHERE EMP_NO='CCBZZP'; 176. 

/*+CHOOSE*/
表明如果数据字典中有访问表的统计信息,将基于开销的优化方法,并获得最佳的吞吐量;
表明如果数据字典中没有访问表的统计信息,将基于规则开销的优化方法;
例如:
SELECT /*+CHOOSE*/ EMP_NO,EMP_NAM,DAT_IN FROM BSEMPMS WHERE EMP_NO='CCBZZP';


/*+RULE*/
表明对语句块选择基于规则的优化方法.
例如:
SELECT /*+ RULE */ EMP_NO,EMP_NAM,DAT_IN FROM BSEMPMS WHERE EMP_NO='CCBZZP';


/*+FULL(TABLE)*/
表明对表选择全局扫描的方法.
例如:
SELECT /*+FULL(A)*/ EMP_NO,EMP_NAM FROM BSEMPMS A WHERE EMP_NO='CCBZZP';


/*+ROWID(TABLE)*/
提示明确表明对指定表根据ROWID进行访问.
例如:
SELECT /*+ROWID(BSEMPMS)*/ * FROM BSEMPMS WHERE ROWID>='AAAAAAAAAAAAAA' AND EMP_NO='CCBZZP';


/*+CLUSTER(TABLE)*/
提示明确表明对指定表选择簇扫描的访问方法,它只对簇对象有效.
例如:
SELECT /*+CLUSTER */ BSEMPMS.EMP_NO,DPT_NO FROM BSEMPMS,BSDPTMS
WHERE DPT_NO='TEC304' AND BSEMPMS.DPT_NO=BSDPTMS.DPT_NO;


/*+INDEX(TABLE INDEX_NAME)*/
表明对表选择索引的扫描方法.
例如:
SELECT /*+INDEX(BSEMPMS SEX_INDEX) USE SEX_INDEX BECAUSE THERE ARE FEWMALE
BSEMPMS */ FROM BSEMPMS WHERE SEX='M';

/*+INDEX_ASC(TABLE INDEX_NAME)*/
```


