2021年12月31日

### Oracle简明总结

#### 创建表

```SQL
--CREATE TABLE语句
CREATE TABLE schema_name.table_name(
	column_1 data_type column_constraint,
    column_2 data_type column_constraint,
    ...
    table_constraint
);
```

注释：

- 首先，在CREATE TABLE子句中，指定新表所属的表名和模式名称。
- 其次，在圆括号内列出所有列。如果一个表有多个列，则需要用逗号分隔每个列的定义。列定义包括列名，后跟它的数据类型。列如：NUMBER, VARCHAR2和列约束，如 NOT NULL，主键，约束检查。
- 最后，如果适用，列如：主键，外键，约束检查，则为表添加约束。

注意：用户权限问题，必须具有CREATE TABLE系统权限才能在模式中创建新表，并使用CREATE ANY TABLE系统特权在其他用户的·模式中创建新表。除此之外，新表的所有者必须具有包含新表或UNLIMITED TABLESPACE系统特权的表空间的配额。

```SQL
--ORACLE 12C写法
CREATE TABLE ot.persons(
	person_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
    first_name VARCHAR2(50) NOT NULL,
    last_name VARCHAR2(50) NOT NULL,
    PRIMARY KEY(person_id)
);
```

解释：

person表有三列：person_id, first_name和last_name, person_id是标识表中唯一行的标识列。person_id列的数据类型是NUMBER。子句GENERATED BY DEFAULT AS IDENTITY 只是Oracle生成一个新的整数，并在列中插入新行时将其用于列。

frist_name列的类型为VARCHAR2，最大长度为50。意味着不能在first_name列中插入长度大于50的字符。另外，NOT NULL列约束防止frist_name列具有NULL值。



last_name列具有与frist_name列相同的特征。PRIMARY KEY子句将person_id列指定为主键列，用于标识个人表中的唯一行。

##### CREATE TABLE AS

CREATE TABLE AS语句用于通过复制现有表的列从现有表来创建新表。

注意：如果以这种方式创建表，则新表将包含现有表中的记录。

```SQL
--CREATE TABLE AS语法
CREATE TABLE new_table
AS (SELECT * FROM old_table);
```

#### 修改表结构

ALTER TABLE语句修改现有表结构。

```SQL
--ALTER TABLE语法
ALTER TABLE table_name action;
```

解释：

- 首先，指定要修改的表名称。
- 其次，指出想在表名称后执行的操作。

ALTER TABLE语句可用来：

- 添加一个或多个列
- 修改列定义
- 删除一列或多列
- 重命名列
- 重命名表

##### ALTER TABLE示例

```SQL
CREATE TABLE persons(
	person_id NUMBER GENERTED BY DEFAULT AS IDENTITY,
    first_name VARCHAR2(50) NOT NULL,
    last_name VARCHAR2(50) NOT NULL,
    PRIMARY KEY(person_id)
);

--ORACLE ALTER TABLE ADD列：将新列比添加到表中
ALTER TABLE table_name
ADD column_name type constraint;

--示例：将一个名为brithdate的新列添加到persons
ALTER TABLE persons
ADD brithdate DATE NOT NULL;

--ORACLE ALTER MODIFY列示例：修改列的属性
ALTER TABLE table_name
MODIFY column_name type constraint;

--示例
ALTER TABLE persons MODIFY birthdate DATE NULL;

--修改多列语法
ALTER TABLE table_name
MODIFY(
	column_1 type constraint,
    column_1 type constraint,
);

--ORACLE ALTER TABLE DROP COLUMN示例：从表中删除现有的列
ALTER TABLE table_name
DROP COLUMN column_name;

--示例：从表结构中删除列，并删除存储在该列中的数据
--从persons表中删除brithdate日期类型的列
ALTER TABLE persons
DROP
	COLUMN brithdate;

--同时删除多个列语法
ALTER TABLE table_name
DROP (column_1, column_2,.....);

--ORACLE ALTER TABLE RENAME列示例
--从版本9i（i: Internet）,ORACLE添加了一个用于崇明名列的子句
ALTER TABLE table_name
RENAME COLUMN column_name TO new_name;

--示例：将first_name列重名为forname列
ALTER TABLE persons
RENAME COLUMN first_name TO forename;

--ORACLE ALTER RENAME表的列子：
--将一个表重命名为一个新的name的表名
ALTER TABLE table_name
RENAME TO new_table_name;

--示例：将users表重命名为people表
ALTER TABLE person RENAME TO people;
```

#### 表添加列

ALTER TABLE ADD语句向表中添加一列或多列。

```SQL
--ALTER TABLE ADD语法
ALTER TABLE table_name
ADD column_name data_type constraint;
```

解释：

- 首先，在ALTER TABLE子句之后指定要添加新列的表的名称
- 其次，指定列名，数据类型及其约束

注意：不饿能添加表中以及存在的列：这样做会导致错误。另外，ALTER TABLE ADD列语句在表的末尾添加新列。Oracle没有提供直接的方法来允许像其他数据库系统（MySQL）那样指定新列的位置。

```SQL
--添加多个列语法
ALTER TABLE table_name
ADD(
	column_name_1 data_type constraint,
    column_name_2 data_type constraint,
    ....
);
```

##### Oracle ALTER TABLE ADD示例

创建members表

```SQL
--12C语法
CREATE TABLE members(
	member_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
    first_name VARCHAR2(50),
    last_name VARCHAR2(50),
    PRIMARY KEY(member_id)
);

--将一个名为brith_date的新列添加到members表
ALTER TABLE members
ADD brith_date DATE NOT NULL;
--brith_date列是一个DATE列，它不接受NULL.
```

#### 删除表

DROP TABLE语句删除现有的表。将表移动到回收站或从数据库中完全删除。

```SQL
--DROP TABLE语法
DROP TABLE schema_name.table_name
[CASCADE CONSTRAINT | PURGE];
```

解释：

- 首先，指出在DROP TABLE子句之后删除的表机器模式。如果不明确指定的名称，则该语句假定从模式中删除该表。
- 其次，指定CASCADE CONSTRAINT子句删除引用表中主键和唯一键的所有参照完整性约束。如果存在这中引用完整性约束，斌且不是有此子句。Oracle将返回错误并停止删除表。
- 最后，如果·像删除表格斌且一次释放与关联的空间，指定PURGE子句。通过使用PURGE子句，Oracle不会将表及其依赖对象放入回收站。

注意：PURGE子句不允许回滚或恢复删除的表。因此，如果不希望敏感数据出现回收站中，很有效。

#### 删除列

DROP COLUMN语句从表中删除一个或多个列。

Oracle使用SET UNUSED COLUMN子句删除列，从大表中删除列的过程可能耗费时间和资源。因此，通常使用ALTER TABLE SET UNUESD COLUMN语句来逻辑删除列。

```SQL
ALTER TABLE table_name
SET UNUSED COLUMN column_name;
```

当执行了该语句，该列就不再可见。在非高峰时段，可以使用以下语句在物理上删除未使用的列

```SQL
ALTER TABLE table_name
DROP UNUSED COLUMNS;
```

如果要减少积累的撤销日志量，可以使用CHECKPOINT选择，该选项在指定的行数已被处理后强制检查点。

```SQL
ALTER TABLE table_name
DROP UNUSED COLUMNS CHECKPOINT 250;
```

#### 修改列定义

ALTER TABLE MODIFY列语句来更改现有列的定义。要更改表中列的定义，如下

```SQL
ALTER TABLE table_name
MODIFY column_name action;
--要修改表的列，需要指定要执行的列名、表名和操作
```

Oracle允许执行多种操作，以下是主要常用的操作：

- 修改列的可见性
- 允许或不允许NULL值
- 缩短或扩大列的大小
- 更改列的默认值
- 修改虚拟列的表达式

修改多个列

```SQL
--语法
ALTER TABLE table_name
MODIFY(
	column_name_1 action,
    column_name_2 action,
    .....
);
```

#### 截断表

TRUNCATE TABLE语句用于更快有效地从表中删除所有数据(也叫阶段表)。要从表中删除所有数据，可以不适应不带WHERE子句地DELETE语句。

```SQL
DELETE FROM table;
```

解释：

- 对于少量行记录地表，DELETE语句效率高
- 对于用于大量行记录地表时，使用DELETE语句删除所有数据效率并不高

==Oracle引入了TRUNCATE TABLE语句，用于删除大表中的所有行。==

```SQL
--ORACLE TRUNCATE TABLE语句
TRUNCATE TABLE schema_name.table_name
[CASCADE]
[[PRESERVER | PURGE MATERIALIZED VIEW LOG]]
[[DROP | REUSE] STORAGE]
```

默认情况下，要从表中删除所有行，需要指定TRUNCATE TABLE子句中截断的表的名称

```SQL
TRUNCATE TABLE table_name;
```

在这种情况下，因为我们没有明确指定模式名称，所有Oracle假定从当前的模式截断表。入宫表通过外键约束与其他表有关系，则需要使用CASCADE子句

```SQL
TRUNCATE TABLE table_name
CASCADE;
```

在这种情况下，TRUNCATE TABLE CASCADE语句删除table_name表中的所有行，并递归地截断链中地关联表。

注意：TRUNCATE TABLE CASCADE语句需要使用ON DELETE CASCADE子句定义外键约束才能工作。

通过MATERIALIZED VIEW LOG子句，可以指定在表上定义地物化视图日志是否在截断表时被保留或者清除。默认情况下，物化视图日志被保留。

STORAGE子句允许选择删除或删除或重新使用由截断行和关联索引（如果有的话）释放的存储。默认情况下，存储被删除。

注意：要截断表，它必须在自己创建的模式中，或者需要具有DROP ANY TABLE系统权限。

#### 重命名表

RENAME语句重命名数据库中的表。要重命名表，可以使用以下Oracle RENAME表语句

```SQL
RENAME table_name TO new_name
```

解释：RENAME表语句中

- 首先，指定将要重命名的表名称
- 其次，指定新的表名，表名不能与统一模式中的另一个表相同

注意：一旦执行REANME语句，就不能回滚。

当重命名表时，Oracle自动将旧表上的索引，约束和授权转移到新表上。另外，它使依赖重命名表（原表）的所有对象失效，如视图，存储过程，函数和同义词。

#### `NUMBER`类型

Oracle NUMBER数据类型用于存储可能为负值或正值的数值。

```SQL
--NUMBER语法
NUMBER[(precision [, scale])]
```

NUMBER数据类型具有精度和尺度：

- 精度时一个数字的位数。范围从1到38.
- 尺度是数字中小数点右侧的位数。范围从-84到127。

```SQL
--示例：数字1234.56的精度是6，尺度是2，要存储这个数字，则定义为：
NUMBER(6, 2)

--定义一个可以存储数值的数字，其数值范围和精度都是最大的
NUMBER

--定义一个定点数字
NUMBER(p, s)

--定义一个整数
NUMBER(P)

--定义一个标识精度为P，尺度为0的定点数
NUMBER(P, 0)

--Oracle允许规模为负数
NUMBER(5, -2)
```

注意：如果在NUMBE(P, S)列中插入数字，并且数字超过精度P，则Oracle将发出错误。但是，如果数量超过尺度S，则Oracle将对该值进行四舍五入。

##### NUMBER数据类型别名

Oracle包含许多可用于定义数字列的别名，如下表所示：

|  ANSI数据类型  | Oracle NUMBER数据类型 |
| :------------: | :-------------------: |
|     `INT`      |     `NUMBER(38)`      |
|   `SMALLINT`   |     `NUMBER(38)`      |
| `NUMBER(p,s)`  |     `NUMBER(p,s)`     |
| `DECIMAL(p,s)` |     `NUMBER(p,s)`     |

注意：INT, SMALLINT, NUMBERIC 和DECIMAL只是别名。它们不是真正的数据类型。Oracle在内部将这些别名映射到相应的NUMBER数据类型。

#### `FLOAT`类型

Oracle FLOAT数据类型是NUMBER数据类型的子类型。其主要目的是促进与ANSI SQL FLOAT数据类型兼容。

```SQL
--FLOAT语法
FLOAT(P)

--示例：创建一个名为float_demo的新表
CREATE TABLE float_demo(
	f1 FLOAT(1),
    f2 FLOAT(4),
    f3 FLOAT(7)
);
```

解释：

- 只能指定FLOAT数据类型的精度。不能指定尺度，因为Oracle数据库从数据中解析尺度的。FLOAT的最大精度是126.

- FLOAT中，精度是二进制位，而NUMBER中精度是十进制数，可进行进制转换。

- ```SQL
  P(d) = 0.30103 * P(b)
  --根据这个公式，因二进制精度的最大值为26位数，大致等于十进制数位数的38位数。
  ```

  为了使它与SQL ANSI FLOAT兼容，Oracle提供了一些别名，如下表所示：

  |  ANSI SQL FLOAT  | Oracle FLOAT |
  | :--------------: | :----------: |
  |      FLOAT       |  FLOAT(126)  |
  |       REAL       |  FLOAT(63)   |
  | DOUBLE PRECISION |  FLOAT(126)  |

注意：如果不适应FLOAT(63)数据类型，可以使用REAL别名代替。

#### `CHAR`类型

Oracle CHAR 数据类型用于存储固定长度的字符串。CHAR数据类型可以存储1到2000字节的字符串。要定义一个CHAR列，需要用字节或字符来指定一个字符串长度。

```SQL
CHAR(length BYTE)
CHAR(length CHAR)
--如果没有明确指定BYTE或CHAR，那么Oracle会默认使用BYTE。
column_name CHAR --没指定长度，那么长度默认为1
```

插入或更新固定长度字符串列时，Oracle将字符存储为固定长度数据。这意味这如果存储的值小于列中定义的最大长度，则Oracle将空格填充到最大长度的字符串。如果插入一个长度大于列的值，Oracle会返回一个错误。Oracle使用空格填充后来比较CHAR值。

#### `NCAHR`类型

Oracle `NCAHR`数据类型用于存储固定长度的Unicode字符数据。NCHAR的字符只能时AL16UTF16或UTF8，在数据库创建时指定为国家字符集。

当时有NCAHR列创建表时，NCHAR列的最大大小始终在字符串长度定义中

```SQL
CREATE TABLE nchar_demo(
	description NCHAR(10)
);

--示例：description列的最大长度是10个字符。对于NCAHR列的最大大小，不能使用字节长度
description NCAHR(10 BYTE) -- no possible
```

 `NCHAR`列的最大字节长度取决于当前的国家字符集。 它是每个字符中最大字符长度和最大字节数的乘积。 

#### `VARCHAR2`类型

存储可变长度的字符串，可使用Oracle VARCHAR2数据类型。VARCHAR2可以存储1到4000字节的值。意味着对于单字节字符集，最多可以在VARCHAR2列中存储4000个字符。当使用VAECHAR2列创建表时，必须指定最大字符串长度（以字节为单位）。

```SQL
VARCHAR2(max_size BYTE)
--或以字符
VARCHAR2(max_size CHAR)
```

默认情况下，如果没有在`max_size`之后显式指定`BYTE`或`CHAR`，则Oracle使用`BYTE`。 换句话说，`VARCHAR2(N)`列最多可以容纳`N`个字节的字符。

如果存储大小超过`VARCHAR2`列最大长度的字符串，则Oracle发出错误。

例如，如果定义最大长度为`20`的`VARCHAR2`列，则在单字节字符集中最多可以存储`20`个字符。 如果存储了`21`个或更多字符，则Oracle返回错误。

另外，如果在`VARCHAR2(20)`列中存储`10`个字符，则Oracle仅使用`10`个字节进行存储，而不是`20`个字节。 因此，使用`VARCHAR2`数据类型可以帮助您节省表使用的空间。

比较`VARCHAR2`值时，Oracle使用非填充比较语义。

##### VARCHAR2最大长度

从Oracle 12c开始，可以为VARCHAR2数据类型最大长度为32767。Oracle使用MAX_STRING_SIZE参数来控制最大长度。如果MAX_STRING_SIZE时STANDARD，则VARCHAR2的最大大小时4000字节。如果MAX_STRING_SIZE为EXTENDED，则VARCHAR2的大小限制为32767。

如需获取MAX_STRING_SIZE参数的值：

```SQL
SELECT
	name,
	value
FROM
	V$parameter
WHERE
	name = 'max_string_size';
	
--或
SHOW PARAMETER max_string_size;
```

#### `NVARCHAR2`类型

NVARCHAR2是可以存储Unicode字符的Unicode数据类型。NVARCHAR2的字符集是在数据库创建时指定国家字符集。

如需在数据库中查找NVARCHAR2的字符集：

```SQL
SELECT
	*
FROM
	nls_database_parameters
WHERE
	PARAMTER = 'NLS_NCHAR_CHARACTERSET';
```

Oracle数据库服务器中，`NVARCHAR2`数据类型使用`AL16UTF16`字符集，它使用`UTF-16`编码对Unicode数据进行编码。`AL16UTF16`使用`2`个字节来存储一个字符。

`NVARCHAR2`存储可变长度的字符数据。 使用`NVARCHAR2`列创建表时，最大长度始终为字符长度语义，也是`NVARCHAR2`数据类型的默认值，也是唯一的长度语义。

 注意，最大字节长度是每个字符中最大字符长度和最大字节数的乘积。 

##### VARCHAR2与NVARCHAR2 

*首先*，`VARCHAR2`的最大大小可以是字节或字符，而`NVARCHAR2`的最大大小只能是字符。 另外，`NVARCHAR2`的最大字节长度取决于配置的国家字符集。

其次，`VARCHAR2`列只能将字符存储在默认字符集中，而`NVARCHAR2`则可以存储几乎任何字符

以下查询返回`VARCHAR2`数据类型使用的缺省字符集：

```SQL
SELECT
	*
FROM
	nls_database_paramters
WHERE
	parameter = 'NLS_CHARACTERSET';
```

#### `DATE`类型

DATE数据类型允许一疫苗的精度存储包括日期和时间的时间点值。DATE数据类型存储年份（包括世纪），月份，日期，小时数，分钟数和秒数。它的范围从公元4712年1月1日到公元9999年12月31日（共同时代）。默认情况下，如果未明确使用BCE，则Oracle使用CE日期条目。

Oracle数据库有其自己的专用格式来存储日期数据。它使用7个字节的固定长度的字段，每个字段对应于世纪、年、月、日、时、分和秒来存储日期数据。

##### 1、Oracle日期格式

输入和输出的标准日期格式是DD-MON-YY,

 例如由`NLS_DATE_FORMAT`参数的值表示为：
`01-JAN-17`。 

假设想要将标准日期格式更改为`YYYY-MM-DD`，那么可以使用`ALTER SESSION`语句来更改`NLS_DATE_FORMAT`参数的值:

```SQL
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
```

##### 2、使用TO_CHAR()函数格式化日期

TO_CHAR()函数采用DATE值作为参数，根据指定的格式对其进行格式化，并返回一个日期字符串。

```SQL
--示例
SELECT 
	TO_CHAR(SYSDATE, 'MM/DD/YYYY')
FROM
	dual;
```

TO_CHAR()函数用于显示月份名称的语言有NLS_DATE_LANGUAGE参数控制

```SQL
SELECT
	value
FROM
	V$NLS_PARAMETERS
WHERE
	parameter = 'NLS_DATE_LANGUAGE';
```

如果要将当前语言更改为另一个语言（如FRENCH），则需要使用ALTER SESSION语句：

```SQL
ALTER SESSION SET NLS_DATE_LANGUAGE = 'FRENCH';
--ALTER SESSION SET NLS_LANGUAGES = 'SIMPLIFIED CHINESE';
```

##### 3、将字符串转换为日期

由于Oracle使用内部格式存储DATE数据，因此在将日期值存储到日期列前，通常必须将字符串转换为日期值。要转换不是标准格式的日期值，可以使用带有格式字符串的TO_DATE()函数。示例：使用TO_DATE()函数将字符串“Auguest 01, 2017”转换为相应的日期。

```SQL
-- alter session set nls_language='SIMPLIFIED CHINESE';
SELECT
	TO_CHAR('2018-10-21', 'YYYY-MM-DD')
FROM
	dual;
```

##### 4、日期文字

除了使用TO_DATE()函数之外，还可以使用以下语法将日期值指定为字符串文字

```SQL
DATE 'YYYY-MM-DD'
```

注意：使用日期作为文字，必须使用公历。以下显示2017年8月1日的ANSI日期字面值

```SQL
DATE '2017-08-01';
```

ANSI日期文字没有时间部分，必须采用确切格式(`'YYYY-MM-DD'`)。 如果要将时间数据包含在日期值中，则必须使用上面介绍的`TO_DATE()`函数。

##### 5、Oracle DATE

创建一个名为my_events的表

```SQL
CREATE TABLE my_events(
	event_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
    event_name VARCHAR2(255) NOT NULL,
    location VARCHAR2(255) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    PRIMARY KEY (event_id)
);
```

使用INSERT语句插入两个日期文字。可以使用TO_CHAR()函数插入之前将字符串转换为日期

```SQL
INSERT INTO my_events
            (event_name,
             location,
             start_date,
             end_date)
VALUES     ( 'Oracle OpenWorld',
        'San Francisco, CA, USA',
            TO_DATE( '2017-10-01', 'YYYY-MM-DD' ),
            TO_DATE( '2017-10-05', 'YYYY-MM-DD'));
```

#### `TIMESTAMP`类型

TIMESTAMP数据类型用于存储日期和时间数据，包括年、月、日、时、分和秒。存储小数秒，不是有DATE数据类型存储的。

定义TIMESTAMP列

```SQL
column_name TIMESTAMP[(fractional_seconds_precision)]
```

fractionan_seconds_precision指定SECOND字段小数部位。它的范围从0到9，意味着可以使用TIMESTAMP数据类型来存储到纳秒的精度。如果省略fractional_seconds_precison，则默认为6。

如何定义TIMESTAMP列

```SQL
....
start_at TIMESTAMP(2),
....
--start_at列是一个TIMESTAMP列，其分数秒精度设置为微妙
```

##### TIMESTAMP文字

指定TIMESTAMP文字

``` 
TIMESTAMP 'YYYY-MM-DD HH24:MI:SS.FF'
```

说明TIMESTAMP文字

```SQL
TIMESTAMP '1999-12-31 23:59:59:18'
```

##### TIMESTAMP示例

创建一个名为logs的新表，其中包含一个TIMESTAMP列

```SQL
CREATE TABLE logs(
	log_id NUMBER GENERARED BY DEFAULT AS IDENTITY,
    message VARCHAR2(2) NOT NULL,
    logged_at TIMESTAMP(2) NOT NULL,
    PRIMARY KEY(log_id)
);
```

##### 格式化TIMESTAMP值

更改TIMESTAMP值的输出，可以使用TO_CHAR()函数，将TIMESTAMP值或列作为第一个单数，将格式字符串作为第二个参数。

使用TO_CHAR()函数来格式化logged_at列中的值

```SQL
SELECT message
	TO_CHAR(logged_at, 'MONTH DD, YYYY " at" HH24:MI')
```

##### 提取TIMESTAMP组件

提取TIMESTAMP组件（如年、月、日、小时、分钟和秒）使用EXTRACT()函数

```SQL
EXTRACT(componet FROM timestamp);

--示例
SELECT 
    message,
    EXTRACT(year FROM logged_at) year,
    EXTRACT(month FROM logged_at) month,
    EXTRACT(day FROM logged_at) day,
    EXTRACT(hour FROM logged_at) hour,
    EXTRACT(minute FROM logged_at) minute,
    EXTRACT(second FROM logged_at) second
FROM 
    logs;
```

注意：NLS_DATELANGUAGE参数决定日期名称（Thursday）,月份名称（Auguest）以及TIMESTAMP缩写（THU, AUG）的语言。

##### 默认的TIMESTAMP格式

当字符类型的值被转换为TIMESTAMP数据类型时，Oracle使用NLS_TIMESTAMP_FORMAT参数来控制默认时间戳格式。

返回Oracle数据库系统中当前的默认时间戳格式

```SQL
SELECT
	value
FROM
	v$NLS_PARAMETERS
WHERE
	parameter = 'NLS_TIMESTAMP_FORMAT';
```

#### `INTERVAL`类型

Oracle提供了两种日期时间数据类型：用于存储时间点数据

- DATE
- TIMESTAMP

另外，它提供INTERVAL数据类型用于存储一段时间

INTERVAL分为两类：

- INTER YEAR TO MONTH - 间隔使用年份和月份
- INTER DAY TO SECOND - 使用包括小数秒在内的天、小时、分钟和秒存储间隔

##### INTERVAL YEAR TO MONTH

INTERVAL YEAR TO MONTH数据类型使用YEAR和MONTH字段存储一段时间

```SQL
--介绍INTERVAL YEAR TO MONTH
INTERVAL YEAR [(year_precesion)] TO MONTH
```

year_precision代表YEAR字段中的位数。范围从0到9。year_precision是可选的。如果省略year_precision参数，则默认为2。也就是说，默认情况下，最多可以存储99年和11个月的期限，这个期限必须小于100年。

##### INTERVAL YEAR TO MONTH文字

指定INTERVAL YEAR TO MONTH数据类型的文字值

```SQL
INTERVAL 'year[month]' leading(precision) TO trailing
```

leading和trailing可以是YEAY或MONTH

参数：

- year[-month]：`year`和`month`是整个区间的`leading`和`trailing`的整数。 如果`leading`是`YEAR`，`trailing`是`MONTH`，那么`month`字段的范围从`0`到`11`。
  `trailing`列必须小于`leading`列。 例如，`INTERVAL '1-2' MONTH TO YEAR`是无效的，因为`leading`列`YEAR`大于`MONTH`的`leading`字段。
- precision： 是`leading`字段中的最大数字位数。精度范围为:`0~9`，默认值为`2`。 

 说明了`INTERVAL YEAR TO MONTH`文字的示例 ：

|    INTERVAL YEAR TO MONTH文字     | 解释                                                         |
| :-------------------------------: | ------------------------------------------------------------ |
| INTERVAL '120-3' YEAR(3) TO MONTH | 间隔120年，3个月; 由于前导字段的值大于默认精度(2位)，因此必须指定前导字段精度`YEAR(3)`。 |
|      INTERVAL '105' YEAR(3)       | 间隔105年0个月。                                             |
|     `INTERVAL '500' MONTH(3)`     | 间隔500个月。                                                |
|         INTERVAL '9' YEAR         | 间隔9年，相当于`INTERVAL '9-0' YEAR TO MONTH`                |
|        INTERVAL '40' MONTH        | 40个月或3年4个月，相当于`INTERVAL '3-4' YEAR TO MONTH`       |
|        INTERVAL '180' YEAR        | 无效的时间间隔，因为’180’有3个数字，它大于默认精度(2)        |

#### INSERT

将新行插入表中

```SQL
--INSERT语法
INSERT INTO table_name (column_1, column_2, column_3,....column_n)
VALUES(value_1, value2, value_3,......value_n);
```

解释：

- 首先，指定要插入的表的名称-table_name
- 其次，在括号内指定逗号分隔列名的列表
- 最后，指定对应于列列表的逗号分隔值列表

如果值列表与表列具有相同的顺序，可以跳过不指定列的列表。但是这不认为是一种好的做法。

```SQL
INSERT INTO table_name
VALUES (value_1, value2, value3, ....value_n);
```

如果从Oracle INSERT语句中排除一列或多列，则必须指定列列表，因为Oracle需要它与值列表中的值相匹配。在INSERT语句中省略的列将使用缺省值（如果可用）或者如果列接受NULL值，则使用NULL值。

#### INSERT INTO SELECT

INSERT INTO SELECT用于从其他表中选择数据并将其插入到另一张表：

```SQL
INSERT INTO target_table(col1, col2, col3)
SELECT 
	col1,
	col2,
	col3
FROM source_table
WHERE condation;
```

INSERT INTO SELECT语句要求源表和目标表匹配数据类型。

#### INSERT ALL

INSERT ALL语句也被称为多项式插入语句。Oracle提供了两种类型的多项式插入语句：无条件和有条件。

##### 1、无条件的Oracle INSERT ALL语句

将多行插入到表中，要将多行插入到表中，语法如下

```SQL
INSERT ALL
	INTO table_name(col1, col2, col3) VALUES(val1, val2, val3)
	INTO talbe_name(col1, col2, col3) VALUES(val1, val2, val3)
	INTO table_name(col1, col2, col3) VALUES(val1, val2, val3)
Subquery;
```

此语句中，每个值表达式值：val1, val2, 或val3必须引用由子查询的选择列表返回的列对应的值。

如果要是有文字值而不是子查询返回的值，则使用该子查询：

```SQL
SELECT * FROM dual;
```

案例：演示如何将多行插入到表中

首先：创建一个名为fruits的新表

```SQL
CREATE TABLE fruits(
	fruit_name VARCHAR(100) PRIMARY KEY;
    color VARCHAR(100) NOT NULL,
);
```

其次，使用INSERT ALL语句将行插入到fruits表中

```SQL
INSERT ALL 
    INTO fruits(fruit_name, color)
    VALUES ('苹果','红色') 

    INTO fruits(fruit_name, color)
    VALUES ('橙子','橙色') 

    INTO fruits(fruit_name, color)
    VALUES ('香蕉','黄色')
SELECT 1 FROM dual;
```

最后，查询fruits表数据来验证插入结果

```SQL
SELECT
	*
FROM
	fruits;
```

##### 将多行插入到多个表中

还可以使用INSERT ALL语句将行插入到多个表中

```SQL
INSERT ALL
    INTO table_name1(col1,col2,col3) VALUES(val1,val2, val3)
    INTO table_name2(col1,col2,col3) VALUES(val4,val5, val6)
    INTO table_name3(col1,col2,col3) VALUES(val7,val8, val9)
Subquery;
```

##### 有条件的Oracle INSERT ALL

条件多项式插入语句允许根据指定的条件将行插入到表中。显示了条件多项插入语句的语法：

```SQL
INSERT [ ALL | FIRST ]
    WHEN condition1 THEN
        INTO table_1 (column_list ) VALUES (value_list)
    WHEN condition2 THEN 
        INTO table_2(column_list ) VALUES (value_list)
    ELSE
        INTO table_3(column_list ) VALUES (value_list)
Subquery;
```

如果指定了ALL关键字，则Oracle将在WHEN子句中评估每个条件，如果条件评估/计算为true，则Oracle执行相应的INTO子句。

当指定FIRST关键字时，对于由子查询返回的每一行，Oracle都会从WHEN子句的上下方向评估每个条件。如果Oracle发现条件的计算结果为true，则执行相应的INTO子句并跳过给定行的后续WHEN子句。

注意：单条件多项式插入语句最多可以由127个WHEN子句。

有条件的Oracle INSERT ALL示例：`CREATE TABLE`语句创建三个表：`small_orders`，`medium_orders`和`big_orders`，它们具有相同的结构：

```SQL
CREATE TABLE small_orders (
    order_id NUMBER(12) NOT NULL,
    customer_id NUMBER(6) NOT NULL,
    amount NUMBER(8,2) 
);

CREATE TABLE medium_orders AS
SELECT *
FROM small_orders;

CREATE TABLE big_orders AS
SELECT *
FROM small_orders;
```

`INSERT ALL`语句根据订单金额将订单数据插入到三个表：`small_orders`，`medium_orders`和`big_orders`之中

```SQL
INSERT ALL
   WHEN amount < 1000000 THEN
      INTO small_orders
   WHEN amount  
      INTO medium_orders
   WHEN amount > 30000 THEN
      INTO big_orders
 SELECT order_id,
        customer_id,
        (quantity * unit_price) amount
 FROM orders
 INNER JOIN order_items USING(order_id);
```

 通过使用`ELSE`子句插入到`big_orders`表中，这样也可以达到相同的结果，如下所示 

```SQL
INSERT ALL
   WHEN amount < 1000000 THEN
      INTO small_orders
   WHEN amount  
      INTO medium_orders
   ELSE
      INTO big_orders
  SELECT order_id,
         customer_id,
         (quantity * unit_price) amount
  FROM orders
  INNER JOIN order_items USING(order_id);
```

#####  有条件的Oracle INSERT FIRST示例 

```SQL
INSERT FIRST
    WHEN (amount > 30000) THEN
        INTO big_orders
    WHEN (amount 
        INTO medium_orders
    ELSE
        INTO small_orders
 SELECT order_id,
         customer_id,
         (quantity * unit_price) amount
 FROM orders
 INNER JOIN order_items USING(order_id);
```

这个语句对`INSERT ALL`没有任何意义，因为`amount`大于`30000`的订单将被插入到三个表中。

但是，对于`INSERT FIRST`，对于由子查询返回的每一行，Oracle将从上到下评估每个`WHEN`条件：

- *首先*，如果订单`amount`大于`30000`，则Oracle将数据插入到`big_tables`中，并忽略随后的`WHEN`条件。
- *接下来*，如果第一次评估/计算为`false`，且金额大于或等于`10000`，则Oracle将数据插入到`medium_tables`中，并跳过评估/计算`ELSE`子句块。
- *最后*，如果前两个`WHEN`条件评估/计算为`false`，则Oracle在ELSE子句中执行`INTO`子句，将数据插入到`small_orders`表中。

### Oracle INSERT ALL限制

Oracle多表插入语句受以下主要限制

- 可以用来将数据插入到表中，而不是视图和物化视图
- 不能用来将数据插入到远程表
- 所有INSERT INTO子句中的列综合不得超过999
- 一个表集合表达式不饿能在一个多表插入语句使用
- 多表插入语句的子查询不能使用序列

#### UPDATE

更改表中已存在的值

```SQL
UPDATE
	table_name
SET
	column1 = value1,
	column2 = value2,
	column3 = value3,
	...
WHERE
	condition;
```

##### UPDATE更新单个行的一列

以UPDATE语句更改ID为3的零件的成本

```SQL
UPDATE
	table_name
SET
	table_name_set=130
WHERE
	table_name_ID = 3;
```

##### UPDATE更新单个行的多个列

示例：

```SQL
--更新ID为6的零件的前置时间，成本和状态。
UPDATE
	parts
SET
	lead_time = 30,
	cost = 120,
	status = 1
WHERE
	part_id = 6;
```

##### UPDATE 更新多行

增加了parts表中所有零件的成本5%

```SQL
UPDATE
	parts
SET
	cost = cost * 1.05;
```

#### DELETE

从表中删除一行或多行

```SQL
--DELETE语法
DELETE
FROM
	table_name
WHERE
	condition;
```

解释：

- 首先，指定要从中删除数据的表格的名称
- 其次，通过使用WHERE子句中的条件指定应该删除那些行，如果省略了WHERE子句，则Oracle DELETE语句将从表中删除所有行。

注意：使用TRUNCATE TABLE语句删除大型表中的所有行会更快更高效。

#### MERGER

Oracle MERGE语句从一个或多个源表中选择数据并更新或将其插入到目标表中。WHERE语句可指定一个条件来去欸的那个是更新数据还是数据插入到目标表中。

```SQL
MERGER INTO target_table
USING source_table
ON search_condition
	WHERE MATCH THEN
		UPDATE SET col1 = value1, col2 = value2,.....
		WHERE < update_condition>
		[DELETE WHERE < delete_condition>]
	WHERE NOT MATCHED THEN
		INSERT (col1, col2,...)
		values(value1, value2,...)
		WHERE < insert_condition>;
```

解释：

- 首先，指定要在INTO子句中更新或插入的目标表（target_table）
- 其次，指定要更新或插入USING子句中的数据元（source_table）
- 最后，指定合并操作在ON子句中更新或插入的搜索条件

对于目标表中的每一行。Oracle都会评估搜索条件

- 如果结果为true，则Oracle使用源表（source_table）中的相应数据更新该行
- 如果任何行的结果为false，则Oracle将源表（source_table）中相应的行插入到目标表（target_table）中

当想要在单个操作总组合INSERT, UPDATE和DELETE语句时，MERGE语句变得很方便。因为MERGE是确定性语句，所有不能在同一个MERGE语句中多次更新目标表的同一行。将一个可选的DELETE WHERE子句添加到MATCHED子句中。以在合并操作之后进行清理。DELETE子句只删除目标表中与ON和DELETE WHERE子句匹配的行。

##### MERGE前提条件

如果要执行MERGE语句，必须在源表上具有INSERT和UPDATE对象权限。如果使用DELETE子句，则还必须在目标表上具有DELETE对象特权。

```SQL
MERGE INTO member_staging x
USING (SELECT member_id, first_name, last_name, rank FROM members) y
ON (x.member_id  = y.member_id)
WHEN MATCHED THEN
    UPDATE SET x.first_name = y.first_name, 
                        x.last_name = y.last_name, 
                        x.rank = y.rank
    WHERE x.first_name <> y.first_name OR 
           x.last_name <> y.last_name OR 
           x.rank <> y.rank 
WHEN NOT MATCHED THEN
    INSERT(x.member_id, x.first_name, x.last_name, x.rank)  
    VALUES(y.member_id, y.first_name, y.last_name, y.rank);
```

`merge`语句根据`member_id`列中的值(参见上面的`ON`子句)，将`member`表中的每一行与`member_staging`表中的每一行进行比较。

如果两个表的`member_id`列中的值相等，`MERGE`语句只有在两个表的`first_name`,`last_name`或`rank`列的不值时，才将`members`表中的`first_name`,`last_name`或`rank`列的不值作为`member_staging`对应列的值来更新，否则它将`members`的行直接插入`member_staging`表。