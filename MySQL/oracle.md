Oracle数据库的体系结构主要包括：物理存储结构、逻辑存储结构、内存结构和实例进程结构。了解了Oracle的体系结构，就可以对Oracle数据库有一个整体认识，这样有利于后续Oracle的学习。下面我们分别来了解逻辑存储结构、物理存储结构、内存结构和实例集成结构。

## 一、逻辑存储结构

　　逻辑存储结构是Oracle数据库存储结构的核心内容，对Oracle的所有操作都会涉及逻辑存储结构。逻辑存储结构是从逻辑的角度分析数据库的构成，是对数据库存储结构在逻辑概念上的划分。Oracle数据库（Database）从逻辑存储结构上讲，主要包括表空间（Tablespace）、段（Segment）、区（Extent）和数据块（Block）。这四者存在关系为：多个数据块组成一个区；多区组成一个段；多个段组成一个表空间。一个Oracle数据库（数据库本身也属于逻辑结构）由多个表空间组成，Oracle数据库的逻辑存储结构可以表示为下图：

![img](Images/1471179-20190814154746551-547315719.png)

图1

### 1、表空间（Tablespace）

　　在Oracle数据库中，最大的逻辑存储结构是表空间（Tablespace），表空间与物理上的数据文件相对应，一个表空间可以对应多个数据文件，但是一个数据文件只能对应一个表空间。一个表空间的大小等于构成该表空间的所有数据文件大小的综和。我们在数据库中创建的所有内容都存储在表空间中，如果我们没有指定表空间，那么我们在数据库中创建的内容将会存储在默认的表空间中。

　　我们创建数据库时，系统会自动创建一些表空间，这些表空间说明如下：

- **SYSTEM：**系统表空间，包含数据字典(描述数据库自身结构、所有对象、用户及角色的的表)。SYSTEM表空间是数据库中数据字典所处的位置。如果没有SYSTEM表空间，那么数据库就无法运作 。创建数据库后，需要创建存储数据的其他表空间。
- **SYSAUX：**辅助系统表空间，用于减少系统表空间的负荷，提高系统的作业效率。
- **TEMP：**临时表空间，用于存储临时临时数据。
- **EXAMPLE：**实例表空间，存放实例数据库模式对象信息及其培训资料等。
- **UNIDOTBSI：**重做表空间，存放数据库中有关重做的相关信息和数据，当用户对数据库表进行修改，包括INSERT、UPDATE和DELETE操作时，Oracle系统自动使用重做表空间，来临时存放修改前的数据 当所做的修改完成，并提交之后，系统会根据需要保留修改前数据的时间长短，来释放重做表空间的部分空间。
- **USERS：**用户表空间，存放永久性用户对象的数据和私有信息，因此，也称为数据表空间，每个数据库都应该有一个用户表空间，以便在创建用户的时候，将其分配给用户。除了Oracle系统默认创建表空间，用户可以根据应用系统的规模，及其所要存放对象的情况，创建多个表空间，以区分用户数据和系统数据。 

　　通过sql语句可以查看表空间，如下图：

```
select * from dba_tablespaces;
```

 

![img](Images/1471179-20190814171145921-792819390.png)

图2

### 2、段（Segment）

　　在Oracle数据库中，段是一组盘区，这个盘区组成了被Oracle视为一个单位的数据库对象，一个段存储了一个数据库对象（比如一张表，一个索引都属于一个数据库对象。对于数据量大的表可能进行分区处理，当段的区满时，系统会分配另一个区，因此，段的数据区在磁盘上可能是不连续的，一个也可能会由多个段组成）。所以，段一般是数据库终端用户将处理的最小存储单位。

　　按照段中存储存储数据的特征，可以将段分为5种类型：数据段、索引段、临时段、LOB段和回退段。

通过sql语句可以查看数据段类型情况，如下图：

```
select distinct（segment_type） from dba_segments;
```

 

![img](Images/1471179-20190814171614414-947717287.png)

图3

- **数据段：**用于存储表中的数据，在Oracle中，如果用户在表空间创建一个表，那么系统会自动在该表空间中创建一个数据段，而且数据段的名称和表的名称相同。如果创建的是分区表，系统会为每个分区分配一个数据段。
- **索引段：**用于存储表中的索引信息。在Oracle中，如果用户创建了一个索引，则系统会为该索引创建一个索引段，并且索引段的名称与索引的名称相同。如果创建的是分区索引，那么系统会为每个分区索引创建一个索引段。
- **临时段：**用于存储临时数据，在Oracle中，排序或者汇总时产生的临时数据都存储在临时段中，该段由系统在用户的临时表空间中自动创建，并在排序或汇总结束时自动消除。
- **LOB段：**用于存储表中大型数据对象。在Oracle中，大型数据对象类型主要有CLOB和BLOB。
- **回退段：**用于存储用户数据被修改之前的值。在Oracle中，如果需要对用户的数据进行回退操作，也就是恢复操作，就要使用回退段。每个Oracle数据库都应该至少有一个回退段，供数据恢复使用。

### 3、区（Extent）

　　在Oracle中，区（Extent）是磁盘空间分配的最小单位。区由一个或者多个数据块组成，而一个或多个区又组成一个段。

　　段的增大是通过增加区的个数来实现的，但是在一个数据段中，区的个数并不是无限制的。在创建时可以使用MIN_EXTENTS和MAX_EXTENTS来定义区的个数，其中参数MIN_EXTENTS表示段中最少可分配的区的个数，MAX_EXTENTS参数表示一段中最多可以分配的区的个数。

　　通过数据字典DBA_TABLESPACES可以了解表空间信息，以及表空间的最大与最小区个数。

　　

```
select min_extents,max_extents,tablespace_name from dba_tablespaces;
```

![img](Images/1471179-20190814210724866-1545467644.png)

图4

### 4.块（Block）

　　块（Block）是用来管理存储空间的基本单位，也是最小的逻辑存储单位。Oracle数据库是以块为单位进行逻辑读写（I/O）操作的。

　　在创建数据库时，初始化参数DB_BLOCK_SIZE用来指定一个数据块的大小。数据库创建之后，将不能修改数据块的大小。

　　可以通过sql/plus使用如下sql语句查看块的大小。

```
show parameter db_block_size
```

　　在数据库块中可以存储的数据有表数据、索引数据和簇数据等。虽然数据块可以存储不同类型的数据，但是，每个数据库的结构相同。结构如下图所示：

| 块头部   |
| -------- |
| 表目录   |
| 行目录   |
| 空闲空间 |
| 行空间   |

图5

　　由上图可知，一个数据库主要由：块头部、表目录、行目录、空闲空间和行空间五部分组成。

- **块头部：**包含块中的一般属性信息，例如数据块的物理地址、所属段的类型等。
- **表目录：**如果数据块中存储的是某个表的数据（表中一行或多行记录），则关于该表的信息将存放在表目录中。
- **行目录：**用于存储数据块中有效的行信息。
- **空闲空间：**数据块中还没有使用的存储空间。
- **行空间：**表或者索引的数据存储在行空间中，所以行空间是数据块中已经使用的存储空间。

　　块头部、表目录和行目录3者共同组成数据块的头部信息区。块头部信息区中并没有存储实际的数据库数据，只是用来引导Oracle系统读取数据的，如果头部信息区受损，则该数据块将消失，快中存储的数据也将丢失。由于块头部、表目录和行目录所组成的头部信息区并不存储实际数据，所以一个数据块的容量实际上是空闲空间和行空间容量的总和。

## 二、物理结构

　　Oracle数据库在物理上是由存储在磁盘中的操作系统文件所组成的，这些文件就是Oracle的物理存储结构。Oracle数据库在物理上主要由数据文件（*.dbf）、控制文件（*.ctl）和重做日志文件（*.log）组成，参数文件（SPFILE.ORA）、密码文件（PWD.ORA）等与Oracle有关，但从技术上说不属于数据库的附属文件。

　　下面介绍说明这些文件：

#### 　　**1、数据文件（Date File）**

　　指存储数据库数据的文件。例如，表中的记录和索引等都存在数据文件中。在读取数据时，如果用户要读取的数据不在内存的数据缓冲区中，那么Oracle就从数据文件中把数据读取出来，放到内存的缓冲区中去，供用户查询；存储数据时，用户修改或添加的数据会先保存在内存的数据缓冲区中，然后由Oracle的后台进程DBWn将数据写入数据文件。

　　　　数据文件一般有以下几个特点：

　　　　（1）一个表空间（数据库存储的逻辑单位）由一个或多个数据文件组成。

　　　　（2）一个数据文件仅与一个数据库联系，而一个数据库通常包含多个数据文件。

　　　　（3）可以为数据文件设置某些特性以便它们在数据库运行空间不足时能够自动扩展。

　　通过查询数据字典DBA_DATA_FILES和V$DATAFILE来了解数据文件的信息和结构。

```
desc dba_data_files;
```

![img](Images/1471179-20190815153404457-525790267.png)

图6

　　通过数据字典DBA_DATA_FILES，可以了解数据文件的名称、大小以及标识等信息。如上图所示，其中部分字段解释如下：

- **FILE_NAME：**数据文件的名称以及存放路径。
- **FILE_ID：**数据文件在数据库中的ID号。　
- **TABLESPACE_NAME:**数据文件对应的表空间名称。
- **BYTES：**数据文件的大小。
- **BLOCKS：**数据文件所占用的数据块数。
- **STATUS：**数据文件的状态。
- **AUTOEXTENSIBLE：**数据文件是否可扩展。

　　通过数据字典V$DATAFILE可以了解记录的数据文件动态信息，通过该数据字典可以了解数据文件的同步信息。如下：

　　![img](Images/1471179-20190815155634291-1568373252.png)

图7

　　上述图7可以看出，FILE#为数据文件编号；NAME为数据文件名称；CHECKPOINT_CHANGE#为数据文件的同步号，同步号随着系统的运行自动修改，以维持所有数据文件的同步。

#### 2、控制文件（Control File）

　　是一个很小的二进制文件，用于描述数据库的物理结构。在Oracle数据库中，控制文件相当重要，它存放着数据库中数据文件和日志文件的信息。一个Oracle数据库通常包括对个控制文件，在数据库使用过程中，数据库需不断更新控制文件，一旦控制文件受损，那么数据库将无法正常工作。通常，在安装Oracle数据库时会自动创建控制文件。

　　通过数据字典V$CONTROLFILE可以了解控制文件的信息，如下图：

　　

```
select name from v$controfile;
```

 

![img](Images/1471179-20190815161102954-1275651674.png)

图8

　　Oracle数据系统一般会默认创建3个包含相同信息的控制文件，目的为了当其中一个控制文件受损时，可以调用其他控制文件继续工作。

 

#### 3.重做日志文件（Redo Log File）

　　简称日志文件，是记录数据库中所有修改信息的文件。借助日志文件，我们可以保证数据的安全性，也可以实现数据库的备份与恢复。

　　为了确保日志文件的安全，在实际应用中，应允许日志文件进行镜像。一个日志文件和它的所有镜像文件构成一个日志文件组，它们具有相同的信息。同一组的日志文件最好保存到不同的磁盘中，以避免物理损坏带来的麻烦。

　　在日志文件组中，日志文件的镜像个数受参数MAXLOGMEMBERS限制，最多可以有5个。

　　通过数据字典V$LOG可以了解系统当前正在使用哪个日志文件组，如下图：

```
select group#,members,status from v$log;
```

 

![img](Images/1471179-20190815162358246-1952178667.png)

图9

　　通过上图我们可以看到status状态字段为cunrrent表示是系统当前使用的日志文件组，当1日志文件组的空间被占用完后，Oracle数据库会自动转换到另一个日志文件组，不过我们可以使用alter system命令进行手工日志切换，语句如下：

```
alter system switch    logfile；
```

　　Oracle数据库中的日志文件组是循环使用的，当所有日志文件组的空间都使用完后，系统会自动切换到第一个日志文件组。第一个日志文件组中已经有的信息将会被覆盖，这取决于数据库的运行模式。

#### 4、其他文件

　　除数据文件、控制文件和重做日志文件外，还有参数文件、备份文件、归档重做日志文件，以及警告、跟踪日志文件等。

- **参数文件：**用于记录Oracle数据库的基本参数信息，主要包括数据库名和控制文件所在的路径等。分为文本参数文件（Parameter File，PFLIE）和服务器参数文件（Server Parameter File，SPFILE）。
- **备份文件：**文件受损时，可借助备份文件对受损文件进行恢复。
- **归档重做日志文件：**用于对写满的日志文件进行复制并保存，具体功能由归档进程ARCn实现，该进程负责将写满的重做日志文件复制到归档日志目标中。
- **警告、跟踪日志文件：**当一个进程发现了一个内部错误时，它可以将关于错误的信息存储到它的跟踪文件中。而警告文件则是一种特使的跟踪文件，它包含错误的时间说明，而随之产生的跟踪文件则记录该错误的详细信息。

##  三、进程结构

　　系统全局区（System Global Area，SGA）与Oracle进程组合成为Oracle数据库实例。其中，SGA是由Oracle为一个实例分配的一组共享内存区域，而Oracle进程则在系统启动后异步地为所有数据库用户执行不同的任务。

#### 1、集成结构概述

　　我们经常说数据库实例，实例其实就是指的是数据库的内存结构和进程结构。我们安装数据库软件大量的是在安装其内存和进程组件结构。Oracle数据库启动时，首先启动Oracle数据库实例，系统将自动分配SGA，并启动多个后台进程。

　　Oracle数据库实例的进程分类：

　　**1）**用户进程

　　是连接到Oracle DB 的应用程序或工具

　　**2）**数据库进程

　　服务器进程：连接到Oracle实例，在用户建立会话时启动

　　后台进程：在启动Oracle实例时启动

　　**3）** 守护程序/应用程序进程

　　网络监听程序

 　Gridinfrastructure 守护程序

从进程角度一般可以把服务器模式分为两种：

　　专用服务器：对于每个会话，专用服务器进程提供服务；

　　共享服务器：不必为每个连接都提供一个专用服务器进程。分派程序会将多个传入网络会话请求定向到共享服务器进程池。共享服务器进程为所有客户机请求提供服务。一般生产库中都是共享模式；

#### 2.oracle11g进程结构图

![img](Images/1471179-20200508151725987-2121409497.png)

　　系统中运行的后台进程数量众多，用户可以通过V$BGPROCESS 视图查询关于后台进程的信息。

 

#### 3.后台进程分类

**（1）oracle实例的后台进程主要有以下几种：**

• 数据库写进程(DBW*n*)

• 日志写进程(LGWR)

• 检查点进程(CKPT)

• 系统监视器进程(SMON)

• 进程监视器进程(PMON)

• 归档进程(ARC*n*)

• 恢复器进程(RECO)

• 封锁进程(LCK*n*)

• 调度进程(Dnn*n*)

• 快照进程(SNP*n*)

• 作业队列协调程序(CJQ0)

• 作业从属进程(J*nnn*)

• 队列监视器进程(QMN*n*)

**（2）各个进程说明**

 **1>** DBW*n* 进程（Database Writer）：

 　负责将数据库缓冲区高速缓存中经过修改的缓冲区（灰数据缓冲区）写入磁盘。

　　在一个数据库实例中，DBWn进程最多可以启动36个，进程名分别为DBWn0、DBWn1、DBWn2、...DBWnj.

　　了解DBWn之前我们先了解几个概念：

- LRU（Least Recently Used，最近最少使用）：数据缓冲的一种管理机制，只保留最近数据，不保留旧数据。
- DIRTY：表示“脏列”或者“弄脏了的数据”，实际上就是指被修改但是还没有写入数据文件的数据。

 

　　**DBWn进程工作过程：**

- 当一个用户进程产生后，服务器进程查找内存缓冲区是否存在用户进程所需的数据。
- 如果内存中没有需要的数据，则服务器进程从数据文件中读取数据。这时，服务器进程从数据文件中读取数据。这时，服务器进程会首先从LRU中查找是否有存放数据的空闲块。
- 如果LRU中没有空闲块，则将LRU中的DIRTY数据块移入DIRTY LIST（弄脏表）。
- 如果DIRTY LIST超长，则服务器进程通知DBWn进程将数据写入磁盘，刷新缓冲区。
- 当LRU中有空闲块后，服务器进程从磁盘的数据文件中读取数据并存放到数据缓冲区中。

　**注：**

　　　　需要DBWn进程将修改修改后的缓冲区数据写入磁盘数据文件的情况，并不只有DIRTY LIST一种，还有如下几种：

- 当一个服务器进程将缓冲区数据移入DIRTY LIST，而DIRTY LIST超长时，服务器进程通知DBWn进程将数据写入磁盘。
- 当一个服务器进程在LRU中查找DB_LOCK_MAX_SCAN_CNT缓冲区时，如果没有找到空闲的缓冲区，则停止查找并通知DBWn进程将数据写入磁盘
- 出现超时（每次3秒）。此时DBWn进程对LRU表查找指定数目的缓冲区，将所有找到的弄脏缓冲区写入磁盘
- 当出现检查点时，LGWR进程指定修改缓冲区数据，通知DBWn进程将其写入磁盘中。

　　**DBWn进程作用：**

- 管理数据缓冲区，以便用户进程总能找到空闲的缓冲区
- 将所有修改后的缓冲区数据写入数据文件
- 使LRU算法将最近使用过的块保留在内存中
- 通过延迟写来优化磁盘I/O读写

　　**DBWn进程个数：**

　　DB_WRITER_PROCESSES 初始化参数指定了DBW*n* 进程的数量。DBW*n* 进程的最大数量为36。如果用户在启动过程中未指定该进程数，Oracle DB 将根据CPU 和处理器组的数量来决定如何设置DB_WRITER_PROCESSES。注意n代表可以有多个此类进程，但是如果是单处理器服务器，则配置n是没用的。

　　通过show parameter db_writer_processes;命令可以来了解参数信息：

![img](Images/1471179-20200508170051865-244332997.png)

 

 

　　DBWn进程最多可以启动20个，所以DB_WRITER_PROCESSES参数的取值范围是1-36.

 **2>**LGWR日志写入进程（Log Writer）：

　　负责管理日志缓冲区的一个后台进程，用于将日志缓冲区中的日志数据写入磁盘的日志文件中。

　　在数据库运行时，对数据库的修改操作将被记录到日志信息中，这些日志信息首先保存在日志缓冲区，当日志信息达到一定量时，由LGWR进程将日志数据写入日志文件。

　　需要LGWR进程将缓冲区数据中的日志数据写入磁盘的主要情况有如下几种：

- 用户进程提交事务
- 日志缓冲区池已满1/3
- 出现超时
- DBWn进程为检查点清除缓冲区块
- 一个实例只有一个日志写入进程
- 事务被写入日志文件，并确认提交　　

　　日志缓冲区是一个循环缓冲区，当LGER进程将日志缓冲区中的日志写入磁盘日志文件后，服务器进程又可以将新的日志数据保存到日志缓冲区。如果系统需要清除日志缓冲区，则LGWR进程在一个事务提交前就将日志信息写出，然后在用户发出commit命令提交事务时将日志信息写入日志缓冲区。该相应的数据缓冲区改变是延迟的，直到更改有效时才将日志数据写入数据文件。

　　LGWR进程将日志信息同步地写入在线日志文件组的多个日志成员文件中，如果日志文件组的某个成员文件被删除或者不可用，则LGWR进程可以将日志信息写入该组的其他文件中，从而不影响数据库的正常使用。

 **3>**CKPT检查点进程（Check Point）：

　　一般在发生日志切换时产生。在系统运行过程中，当需要将修改后的数据写回数据文件并且产生日志切换时就会产生检查点。检查点保证所有修改过的数据库缓冲区中的数据都被写入磁盘数据文件中。
　　在Oracle数据库中，提供了两个参数控制检查点的产生：一个是LOG_CHECKPOINT_TIMEOUT,用来设置检查点产生的时间间隔；另一个是LOG_CHECKPOINT_INTERVAL,用来设置一个检查点需要填充的日志文件块的数目也就是每产生多少个日志数据，自动产生一个检查点。

　　通过以下命令我们可以了解log_checkpoint_timeout参数信息：

```
show parameter log_checkpoint_timeout; 
```

![img](Images/1471179-20200512110554199-2129978093.png)

 　log_checkpoint_timeout参数默认值为1800，单位为秒。

　　通过以下命令我们可以了解log_checkpoint_interval 参数值：

```
show parameter log_checkpoint_interval;
```

![img](Images/1471179-20200512112741408-1046397166.png)

 

```
　　log_checkpoint_interval参数值默认为0.
```

**4>**SMON系统监视器进程（System Monitor）:　　
　　在实例启动时执行实例恢复，并负责清理不再使用的临时段。在具有并行服务器选项的环境下，SMON进程对有故障的CPU或者实例进行实例恢复。SMON进程被有规律的唤醒，检查是否需要使用，其他进程需要时也可以调用次进程。
**5>**PMON进程监视器进程（Process Monitor）：
　　用于在用户进程出现故障时执行进程恢复操作，并负责清理内存存储区和释放该进程所用的资源。改进程周期性的检查调度进程和服务器进程的状态，如果发现进程已死，则重新启动它。PMON进程被有规律的唤醒，检查是否需要使用，其他进程需要使用时也可以调用此进程。
**6>**ARCn归档进程（Archive Process）：

　　用于将写满的日志文件复制到归档日志文件中，防止日志文件组的循环使用将已有的日志数据覆盖。

　　在一个数据库实例中，ARCn进程最多可以启动10个，进程名分别为：ARC0、ARC1、...ARC9.

　　oracle数据有归档（Archivelog）和非归档（Noarchivelog）两种方式。只有在归档方式下才存在ARCn进程。当ARCn进程在对一个日志文件进程归档操作时，其他任何进程都不可以访问这个日志文件。

　　允许启动的ARCn进程个数由LOG_ARCHIVE_MAX_PROCESSES决定，我们可以通过下面的命令来了解该参数的具体信息。

```
show parameter log_archive_max_processes;
```

![img](Images/1471179-20200512130313036-1792301584.png)

 

　　从上面查询结果可知，目前最多可以启动的ARCn进程个数为4，该参数的取值范围为1-10.

**7>**RECO恢复器进程（Recovery）：

　　存在于分布式数据库系统中，用于自动解决在分布式数据库中出现的事务故障。当一个节点的RECO进程自动地连接到包含有相应数据的分布式事务的其他数据库中时，RECO进程自动维持分布式数据库环境中的数据的一致性，任何在当前已经处理而其他数据库中还未处理的事务将从每一个数据库的事务表中删除。

　　当一个数据库服务器的RECO进程视图与一个远程服务器建立通信时，如果远程服务器不可用或者无法建立网络链接，则RECO进程将自动在一个时间间隔之后再次链接。

**8>**LCKn封锁进程（Lock）：

　　该进程存在于并行服务器中，用于实现多个实例间的封锁。在一个数据库实例中，最多可以启动10个LCKn进程，进程名分别为：LCK0、LCK1...LCK9.

**9>**Dnnn调度进程（Dispatchers）：

　　存在于多线程服务器体系结构中，用于将用户进程连接到服务器进程。在一个数据库实例中，Dnnn进程可以启动多个，进程名分别为D001、D002、...Dnnn。

　　该进程允许用户进程共享有限的服务器进程，当没有调度进程时，每个用户进程需要一个专用的服务器进程。在一个数据库实例中，对每种网络协议至少建立一个调度进程。数据库管理员根据操作系统中每个进程可连接数目的限制，决定需要启动的调度进程的数目，在实例运行时可以增加或删除调度进程。

　　在实例启动时，调度进程为用户连接到Oracle建立一个通信路径，然后每一个调度进程把连接请求的调度进程的地址给予其他用户。当一个用户进程有连接请求时，网络接收器进程分析请求并决定该用户是否可以使用一个调度进程。如果可以，则网络接收器进程返回该调度进程的地址，将用户进程连接到该调度进程，然后由调度进程将用户连接到服务器进程。

**10>**SNPn快照进程（Snapshot Process）：

　　该进程用于处理数据库快照的自动刷新，并通过DBMS_JOB程序包自动运行预定的数据库存储过程、SQL和PL\SQL程序等。

　　在oracle数据库中我们可以通过参数JOB_QUEUE_PROCESS设置快照进程的个数。通过以下命令我们可以了解JOB_QUEUE_PROCESS的参数信息：

```
show parameter job_queue_process;
```

![img](Images/1471179-20200513132417869-1191490618.png)

 

 

 **11>**CJQ0作业队列协调进程(Job Queue Processes)：

　　一般由两类进程组成：

　　作业队列协调进程coordinator job queue process (CJQn)，起到对作业队列的监控作用。

　　执行作业的队列进程job queue processes (Jnnn)，由CJQn完成调度产生。

　　作业队列进程用于批处理，执行用户job，可以将它们看做一个调度服务，用于调度Oracle实例上如PL/SQL语句或存储过程的job。提供开始的时间和调度的时间间隔，作业队列进程可以根据这个配置，自动地周期性地执行。

​     作业队列进程可以被动态地管理。可以允许作业队列客户端根据需要使用多个作业队列进程，当一个作业队列进程进入空闲状态（idle）后，其使用的资源将被释放。

​     动态的作业队列进程可以按指定的时间间隔运行大量的作业。用户的作业是由 CJQ 进程交给作业队列进程执行的。具体步骤如下：

　　1. 名为 CJQ0 的协调进程（coordinator process）定期地从系统JOB$表中选择需要运行的job。被选出的作业将按照时间排序。

　　2. CJQ0进程动态地产生job队列的slave进程来运行这些job，编号从J000-J999。

　　3. 作业队列进程执行一个由 CJQ 进程选出的作业。每个进程每次只能执行一个job。

　　4. 当一个工作队列进程执行完一个作业后，就能够接受下一个作业。如果此时系统中已经没有需要被调度的作业了，此进程将进入休眠状态（sleep state）；此进程还会定期地苏醒（wake up）等待分配其他作业。如果在预设的时间内没有新的作业，此进程将终止。

　　初始化参数JOB_QUEUE_PROCESSES表示实例中可以并行执行的最大作业队列进程数。但是，客户端不应该假设所有的作业队列进程都用于执行job。

**注意：**

　　如果初始化参数JOB_QUEUE_PROCESSES被设置为 0，协调进程(CJQ )将不会被启动。

**12>**其他进程

　　Oracle 数据库中还可能运行其他后台进程。包括：

　　Memory Monitor Light (MMNL)进程负责执行轻量级的且频率较高的和可管理性相关的后台任务，例如捕获会话历史信息，测量值计算等。它与AWR一起起作用，将需要的buffer统计信息写入磁盘。

　　MMAN进程负责执行数据库系统的内部任务。

　　在使用了自动存储管理（Automatic Storage Management）的实例中，RBAL 进程负责协调磁盘组间的负载平衡工作。她可以使多个实例同时访问一个 ASM 磁盘（global open）。最终由 ORBn 进程实际执行数据扩展的负载均衡。实例中可以运行多个 ORBn 进程，分别为ORB0，ORB1，以此类推。

　　当数据库实例使用 ASM 磁盘组时，还要启动 OSMB 进程。此进程负责和 ASM 实例（Automatic Storage Management instance）通信。

　　LMS（Global Cache Service）进程，在RAC环境中存在，该进程管理资源，并提供实例资源交互控制。

　　Change Tracking Writer (CTWR)进程，是10g中的新进程，用于对最近的改变的块进行跟踪，让RMAN可以更快地进行增量备份。